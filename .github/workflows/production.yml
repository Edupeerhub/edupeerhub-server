name: Production CI/CD

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  run-tests:
    name: Run tests (production)
    if: (github.event_name == 'pull_request' && github.event.action != 'closed') || github.event_name == 'push'
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_USER: testuser
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Wait for PostgreSQL to be ready
        run: |
          until pg_isready -h localhost -p 5432 -U testuser; do
            echo "Waiting for PostgreSQL..."
            sleep 2
          done
          echo "PostgreSQL is ready!"

      - name: Setup test env file
        run: |
          cat > .env.test <<'ENV'
          DB_HOST=localhost
          DB_USER=testuser
          DB_PASS=testpass
          DB_NAME=testdb
          DB_PORT=5432
          JWT_SECRET=test-jwt-secret-key
          PORT=3000
          NODE_ENV=test
          ENV

      - name: Verify environment setup
        run: |
          echo "Contents of .env.test:"
          cat .env.test
          echo ""
          echo "Testing database connection..."
          PGPASSWORD=testpass psql -h localhost -U testuser -d testdb -c "SELECT version();"

      - name: Load environment and run migrations tests
        run: |
          export $(grep -v '^#' .env.test | xargs)
          echo "DB_HOST is: $DB_HOST"
          echo "DB_NAME is: $DB_NAME"
          npx sequelize-cli db:migrate --debug
        env:
          NODE_ENV: test

      - name: Run tests
        id: test
        run: |
          export $(grep -v '^#' .env.test | xargs)
          npm test
        env:
          NODE_ENV: test

      - name: Cleanup
        if: always()
        run: rm -f .env.test

  deploy-production:
    name: Deploy to production
    runs-on: ubuntu-latest
    needs: run-tests
    if: github.event_name == 'push'
    environment: production
    steps:
      - name: Checkout (for metadata only)
        uses: actions/checkout@v4
      - name: Deploy via SSH to production
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.PRIVATE_SSH_KEY }}
          script: |
            set -euo pipefail

            APP_NAME="edupeerhub-server"
            ENV_NAME="production"
            SERVICE_ENV="production"   # value for NODE_ENV on server
            BRANCH="main"
            REPO_URL="https://github.com/Edupeerhub/edupeerhub-server.git"
            DEPLOY_DIR="/var/www/${APP_NAME}-${ENV_NAME}"
            SERVICE_NAME="${APP_NAME}-${ENV_NAME}"

            echo "Deploying ${APP_NAME} (${ENV_NAME}) to ${DEPLOY_DIR} on branch ${BRANCH}"

            # Install prerequisites
            sudo apt-get update -y
            sudo apt-get install -y git curl ca-certificates nginx certbot python3-certbot-nginx

            # Install Node.js 20 if missing or wrong version
            if ! command -v node >/dev/null 2>&1 || ! node -v | grep -q "^v20"; then
              echo "Installing Node.js 20 LTS..."
              curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
              sudo apt-get install -y nodejs
            else
              echo "Node.js $(node -v) already installed"
            fi

            # Create deployment directory
            sudo mkdir -p "${DEPLOY_DIR}"
            sudo chown -R $USER:"$USER" "${DEPLOY_DIR}"

            # Clone or update repository
            if [ -d "${DEPLOY_DIR}/.git" ]; then
              echo "Updating existing repo..."
              git -C "${DEPLOY_DIR}" fetch --all --prune
              git -C "${DEPLOY_DIR}" checkout "${BRANCH}"
              git -C "${DEPLOY_DIR}" reset --hard "origin/${BRANCH}"
            else
              echo "Cloning repo..."
              git clone -b "${BRANCH}" --single-branch "${REPO_URL}" "${DEPLOY_DIR}"
            fi
            cd "${DEPLOY_DIR}"

            # Build .env from environment-scoped secrets
            PORT_VALUE="${{ secrets.PRODUCTION_PORT }}"
            cat > .env <<'ENVEOF'
            # Generated by GitHub Actions CD (production)

            # Server
            PORT=__PORT__
            NODE_ENV=__NODE_ENV__
            EMAIL_ENABLED=${{ secrets.EMAIL_ENABLED }}

            # Frontend
            CLIENT_URL=${{ secrets.CLIENT_URL }}

            # Database (prefer DATABASE_URL)
            DATABASE_URL=${{ secrets.PRODUCTION_DATABASE_URL }}
            DB_SSL=${{ secrets.DB_SSL }}

            # Auth
            JWT_SECRET=${{ secrets.JWT_SECRET }}

            # Logging
            LOG_LEVEL=${{ secrets.LOG_LEVEL }}

            # Stream Chat
            STREAM_API_KEY=${{ secrets.PROD_STREAM_API_KEY }}
            STREAM_API_SECRET=${{ secrets.PROD_STREAM_API_SECRET }}

            # Mailtrap
            MAILTRAP_TOKEN=${{ secrets.MAILTRAP_TOKEN }}
            MAILTRAP_ENDPOINT=${{ secrets.MAILTRAP_ENDPOINT }}
            ENVEOF

            # Inject runtime values
            sed -i "s#__PORT__#${PORT_VALUE}#" .env
            sed -i "s#__NODE_ENV__#${SERVICE_ENV}#" .env
            echo "Created .env for ${SERVICE_ENV} at ${DEPLOY_DIR}/.env"

            # Install dependencies
            npm ci --no-audit --no-fund

            # Run database migrations with environment loaded
            set -a
            . ./.env || true
            set +a
            NODE_ENV="${SERVICE_ENV}" npx sequelize-cli db:migrate || {
              echo "Migrations failed" >&2; exit 1;
            }

            # Configure systemd service (idempotent)
            SERVICE_FILE="/etc/systemd/system/${SERVICE_NAME}.service"
            sudo bash -c "cat > '${SERVICE_FILE}'" <<SERVICEEOF
            [Unit]
            Description=${APP_NAME} (${ENV_NAME})
            After=network.target
            [Service]
            Type=simple
            User=${{ secrets.SERVER_USER }}
            WorkingDirectory=${DEPLOY_DIR}
            EnvironmentFile=${DEPLOY_DIR}/.env
            ExecStart=/usr/bin/node src/server.js
            Restart=always
            RestartSec=10
            [Install]
            WantedBy=multi-user.target
            SERVICEEOF

            sudo systemctl daemon-reload
            sudo systemctl enable "${SERVICE_NAME}" || true
            sudo systemctl restart "${SERVICE_NAME}"
            sudo systemctl status "${SERVICE_NAME}" --no-pager -l || true

            # Configure Nginx (idempotent)
            NGINX_CONF="/etc/nginx/sites-available/${SERVICE_NAME}"
            sudo bash -c "cat > '${NGINX_CONF}'" <<NGINXEOF
            server {
                listen 80;
                server_name ${{ secrets.PRODUCTION_SERVER_URL }};

                location / {
                    proxy_pass http://localhost:${PORT_VALUE};
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host \$host;
                    proxy_cache_bypass \$http_upgrade;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                }
            }
            NGINXEOF

            if [ ! -L "/etc/nginx/sites-enabled/${SERVICE_NAME}" ]; then
              sudo ln -s "${NGINX_CONF}" "/etc/nginx/sites-enabled/${SERVICE_NAME}"
            fi

            # Test and reload Nginx
            sudo nginx -t
            sudo systemctl reload nginx

            # Configure SSL with certbot if not already configured
            if ! sudo certbot certificates | grep -q "${{ secrets.PRODUCTION_CLIENT_URL }}"; then
              echo "Obtaining SSL certificate for ${{ secrets.PRODUCTION_CLIENT_URL }}..."
              sudo certbot --nginx -d "${{ secrets.PRODUCTION_CLIENT_URL }}" --non-interactive --agree-tos -m "${{ secrets.SSL_EMAIL }}" --redirect
            else
              echo "SSL certificate for ${{ secrets.PRODUCTION_CLIENT_URL }} already exists"
            fi

	    sudo nginx -t
            sudo systemctl reload nginx
            
            # Health check
            sleep 2
            if command -v curl >/dev/null 2>&1; then
              curl -fsS "http://localhost:${PORT_VALUE}/api/health" || true
            fi
            echo "Deployment completed: ${SERVICE_NAME} running on port ${PORT_VALUE}"

